6. Массивы
	6.1. Виды массивов
		6.1.1. Одномерные массивы
		6.1.2. Многомерные массивы
			6.1.2.1. Матрицы
			6.1.2.2. Треугольные массивы
	6.2. Простые сортировки
		6.2.1. Пузырьковая сортировка
		6.2.2. Шейкерная сортировка
		6.2.3. Сортировка методом вставки
		6.2.4. Сортировка методом выбора
	6.3. Алгоритмы поиска
		6.3.1. Линейный поиск
		6.3.2. Поиск методом половинного деления
		6.3.3. Интерполяционный поиск
	6.4. Сложные сортировки
		6.4.1. Быстрая сортировка/Сортировка Хоара(Quick sort)
		6.4.2. Сортировка слиянием(Merge sort)
		6.4.3. Сортировка подсчётом(Counting sort)
		6.4.4. Алгоритм со списком(pigeonhole sorting)
		6.4.5. Блочная сортировка
		6.4.6. Улучшенная сортировка вставками (Сортировка Шелла)


////////////// 6. Массивы
Добрый день, коллеги. Сегодняшняя тема - массивы. Что же это такое.
Массивы — обыкновенные структуры данных, интуитивно понятные, легкие в использовании и поддерживаемые большинством языков программирования. Они настолько просты, что закономерно усомниться, стоит ли их рассматривать на курсе об алгоритмах. В большинстве случаев массивы используются по прямому назначению, но иногда им находят особое применение, поэтому все же стоит рассказать и о них.
Массив — это большое количество непрерывной памяти, доступ к которой осуществляется с помощью индексов (их количество указывает на размерность массива). Его легко представить в виде совокупности ящиков, в которых программа хранит значения.
——————————
Слайд с картинкой - виды массивов
—————
При создании массива программа, как правило, задает его размерность и границы этой размерности. Например, в следующем коде на языке Cи объявлен массив arr, имеющий 10 строк и 20 столбцов.    char arr[10][20];

////////////// 6.1. Виды массивов
Массивы бывают следующих видов: одномерные и многомерные. Давайте рассмотрим каждый из них подробнее.

////////////// 6.1.1. Одномерные массивы
Одномерный массив представляет собой совокупность однотипных элементов, доступ к которым определяется одним индексом. Все элементы массива сохраняются в памяти последовательно, первый элемент имеет нулевой индекс (далее 1, 2, и т.д.). Индекс – это порядковый номер элемента в массиве.
Массив перед использованием в программе, как и обычную переменную, следует объявить. Объявить одномерный массив можно следующим образом:
тип_элементов имя_массива[размер_массива];

где тип_элементов – допустимый в С тип элементов массива;
имя_массива – идентификатор, задаваемый по тем же правилам, что и имена обычных переменных;
размер_массива – это количество элементов массива.

Давайте создадим одномерный массив на 10 элементов и заполним его какими то числами
int arr[10] = {5, 8, 2, 4, 1, 6, 45, 3, 8, 12};

А теперь найдем в этом массиве какое-нибудь число
int i;
for (i = 0; i < SIZE; i++) {
if (arr[i] == n) return 0;
}

Среднее арифметическое всех элементов массива
float sum = 0; 
int i;
for(i = 0;i < SIZE; i++) {
sum += a[i];
} 
printf(“%f”, sum/SIZE);

Минимальное значение
int i;
int min = arr[0];
for (i = 0; i < SIZE; i++) {
if (min >= arr[i]) min = arr[i];
}
return min;

Максимальное значение
int i;
int max = arr[0];
for (i = 0; i < SIZE; i++) {
if (max <= arr[i]) max = arr[i];
}
return max;

/////////////6.1.2. Многомерные массивы
Многомерный массив – это таблица данных в двух или более измерениях. Для обращения к элементу такого массива нужно поочередно использовать соответственное мерности количество индексов. Такая комбинация называется координатами ячейки массива.
Синтаксис остаётся прежним, добавляется только новая размерность
<тип> <имя>[размерность1][размерность2]...;
Например, двумерный массив
int a[2][3];
Трёхмерный массив
int a[3][4][5];

/////////////6.1.2.1. Матрицы
Самым простым многомерным массивом является двумерный массив. Его несложно представить визуально как плоскую таблицу. Если выбрать в этой таблице некую ячейку, то соответственные номера строки и столбца и будут ее координатами.
Создадим двумерный массив размером 3 строки и 5 столбцов. И выведем ее на экран
#define SIZE_ROWS 3
#define SIZE_COLS 5

int main (int argc, const char* argv[]) {
    char arr[SIZE_ROWS][SIZE_COLS];
    int i, j;
    for (i = 0; i < SIZE_ROWS; i++) {
    	for (j = 0; j < SIZE_COLS; j++) {
    		arr[i][j] = ' ';
    	}
    }

    for(i = 0; i < SIZE_ROWS; i++) {
    		for(j = 0; j < SIZE_COLS; j++)
    			printf("[%c]", arr[i][j]);
    		printf("\n");
    	}

    return 0;
}
А теперь давайте напишем алгоритм таблицы умножения и выведем ее на экран
#include <stdio.h>
#define SIZE_ROWS 10
#define SIZE_COLS 10

void multTable (int** table) {
	int i, j;
	for (i = 0; i < SIZE_ROWS; i ++) {
	for (j = 0; j < SIZE_COLS; j++) {
	*((*(table + i)) + j) = ((i+1) * (j+1));
	}}
}

void printArray (int** table) {
	int i, j;
	for(i = 0; i < SIZE_ROWS; i++) {
	    for(j = 0; j < SIZE_COLS; j++) {
	    	printf("%3d ", *((*(table + i)) + j));
	    }
	    printf("\n");
    }
}

int** initMatrix (int** table) {
	table = (int**) calloc(sizeof(int*), SIZE_ROWS);
	int i;
	for (i = 0; i < SIZE_ROWS; i++) {
		*(table + i) = (int*) calloc(sizeof(int), SIZE_COLS);
	}
	return table;
}

int main (int argc, const char* argv[]) {
    int **arr = initMatrix(arr);
    multTable(arr);
    printArray(arr);

    return 0;
}

Давайте рассмотрим еще один алгоритм для большего понимания двумерного массива.
Поменяем строки местами. Для того, чтобы сделать функцию универсальной, будем передавать номера строк в функцию из функции main.

#include <stdio.h>
#define SIZE 5

void printArr(int arr[SIZE][SIZE]) {
	int i, j;
	for (i = 0; i < SIZE; i++) {
		for (j = 0; j < SIZE; j++) {
			printf("%3d ", arr[i][j]);
		}
		printf("\n");
	}
	printf("\n");
}

void initArr (int arr[SIZE][SIZE]) {
	int i, j, count = 0;
		for (i = 0; i < SIZE; i++) {
			for (j = 0; j < SIZE; j++) {
				count++;
				arr[i][j] = i;
			}
		}
}

void changeCols(int arr[SIZE][SIZE], int firstCols, int secondCols) {
	int i, temp;
	for (i = 0; i < SIZE; i++) {
		temp = arr[secondCols][i];
		arr[secondCols][i] = arr[firstCols][i];
		arr[firstCols][i] = temp;
	}
}

int main () {
	int matrix[SIZE][SIZE];
	initArr(matrix);
	printArr(matrix);
	int firstCols = 4, secondCols = 2;
	changeCols(matrix, firstCols, secondCols);
	printArr(matrix);

	return 0;
}


/////////6.1.2.2. Треугольные массивы
В некоторых случаях пространство можно сэкономить, используя вместо обычных прямоугольных массивов треугольные. В треугольном массиве элементы, расположенные над диагональю (там, где индекс столбца больше, чем индекс строки), имеют значения по умолчанию: 0, null или пустое место.
Построить треугольный массив несложно: достаточно упаковать все исходные значения в одномерный массив, пропустив ненужные элементы. Трудности могут возникнуть при определении того, насколько большим должен быть одномерный массив и как назначить и связать строки и столбцы с его индексами.
На слайде приведено количество записей, необходимое для построения треугольных массивов различных размеров.
—————
Картинка таблица 4.1
—————
Если проанализировать эту таблицу, можно найти закономерность: количество ячеек для N строк равно количеству ячеек, необходимому для N – 1 строк плюс N. Взглянув на треугольный массив более внимательно, вы поймете, что почти половина его записей умещается в квадратном массиве с таким же количеством строк. Если строк N, то в квадратном массиве будет N2 записей, поэтому очевидно, что их количество в соответствующем треугольном массиве будет также включать величину N2. Взяв обычное квадратное уравнение A u N2 + B u N + C и подставив значения из таблицы 4.1, вы определите A, B и C и придете к выводу, что уравнение сводится к (N2 + N)/2. Таким образом, чтобы построить треугольный массив с количеством строк N, нужно назначить одномерный массив, содержащий (N2 + N)/2 элементов.На следующем этапе следует выяснить, как привести в соответствие строки и столбцы с индексами одномерного массива. Чтобы узнать индекс для записи со строкой r и столбцом c, нужно определить, сколько элементов ей предшествует в одномерном массиве.Посмотрите на рисунок 4.5 и обратите внимание на количество записей, идущих перед ячейкой с координатами (3, 2). Полные строки выделены жирной линией. Количество записей в них равноценно количеству записей в треугольном массиве с тремя строками, а вы уже знаете, как его рассчитывать.
—————
Рисунок 4.5
——————
Элементы, идущие перед целевой записью в ячейке (3, 2) и не входящие в полную строку, размещаются слева. В данном примере нужная нам запись расположена в столбце 2, а перед ней в той же строке стоят еще два элемента. В общем случае формула индекса для записи со строкой r и столбцом c будет выглядеть так: ((r– 1)2 + (r– 1))/2 +c.Эти две формулы облегчают работу с треугольными массивами. Используйте первую, чтобы узнать, сколько элементов должен содержать массив с количеством строк N, а вторую, чтобы привести в соответствие строки и столбцы с индексами в одномерном массиве.——————
int findIndex (int r, int c) {
return ((r - 1) * (r - 1) + (r - 1) / 2 + c;
}
——————
Приведенный алгоритм легко упростить, заключив треугольный массив в класс. Создав методы get и set, вы сможете рассматривать данный массив как обычный.
Последнее, что стоит рассмотреть, — как класс треугольного массива воспринимает запросы к несуществующим элементам. Что, например, должно происходить, если программа попытается получить доступ к записи (1, 4) в верхней половине треугольника? Все зависит от обстоятельств: вы можете вернуть значение по умолчанию, поменять местами строку и столбец и вернуть полученное значение или же сгенерировать исключение.

//////////////6.2. Простые сортировки
Переходим к сортировкам.
Под сортировкой обычно понимают процесс перестановки объектов данного множества в определенном порядке. Цель сортировки - облегчить последующий поиск элементов в отсортированном множестве. В этом смысле элементы сортировки присутствуют почти во всех задачах. Упорядоченные объекты содержатся в телефонных книгах, в ведомостях подоходных налогов, в оглавлениях, в библиотеках, в словарях, на складах, да и почти всюду, где их нужно разыскивать. Даже маленьких детей приучают приводить вещи «в порядок», и они сталкиваются с некоторым видом сортировки задолго до того. Как узнают что-либо об арифметике.
//////////////6.2.1. Пузырьковая сортировка
	Начнём с самого простого для запоминания (но, естественно, не самого эффективного) пузырькового алгоритма сортировки. В этом алгоритме сравниваются два соседних элемента массива, и при необходимости меняются местами, таким образом, одни элементы поднимаются вверх, другие спускаются вниз.

#include <stdio.h>
#define MaxN 100
void swap(int *a,int *b) {
  int t = *a;
  *a = *b;
  *b = t;
}

// Распечатываем массив
void Print(int *arr, int len) {
  int i;
  for(i = 0; i < len; i++)
  	printf("%6i ", arr[i]);
  printf("\n");
}

void fillRandom(int *arr, int len, int border) {
    int i;
    for (i = 0; i < len; i++)
        *(arr + i) = (my_random(border));
}

int main(int argc, char *argv[]) {
   int arr[MaxN];
   fillRandom(arr, MaxN, 100);
   puts(“Array before sort”);
   Print(arr, MaxN);
   int i, j;
   for (i = 0;i < MaxN; i++)
   	   for (j = 0; j < MaxN - 1; j++)
       	   if (a[j] > a[j + 1])
           	   five_swap(&arr[j], &arr[j + 1]);
   puts("Array after sort");
   Print(arr, MaxN);
   return 0;
}

/////////////6.2.2. Шейкерная сортировка
это небольшой апдейт над пузырьковой. Поскольку, очевидно, после первого прохода по массиву сверху вниз, своё место займёт самый большой элемент, то на следующей итерации мы пойдём от меньшего к большему, таким образом найдя и поставив на место самый маленький элемент, и так далее, постоянно сдвигая левую и правую границу в сторону центра
    int left = 1;
    int right = MaxN - 1;
    while (left <= right)
    {
        int i;
        for (i = right; i >= left; i--)
            if (arr[i - 1] > arr[i]) five_swap(&arr[i], &arr[i - 1]);
        left++;
        for (i = left; i <= right; i++)
            if (arr[i - 1] > arr[i]) five_swap(&arr[i], &arr[i - 1]);
        right--;
    }
	Шейкерная сортировка быстрее обычной пузырьковой хотя бы только потому, что немалая часть элементов упорядочивается с каждым следующим проходом по массиву, не только с соседом, но и относительно массива в целом. 

////////////////6.2.3. Сортировка методом вставки
Сортировка вставками (Insertion Sort) — это простой алгоритм сортировки. Суть его заключается в том что, на каждом шаге алгоритма мы берем один из элементов массива, находим позицию для вставки и вставляем. Стоит отметить что массив из 1-го элемента считается отсортированным.

Словесное описание алгоритма звучит довольно сложно, но на деле это самая простая в реализации сортировка. Каждый из нас, не зависимо от рода деятельности, применял алгоритм сортировки, просто не осознавал это:) Например когда сортировали купюры в кошельке — берем 100 рублей и смотрим — идут 10, 50 и 500 рублёвые купюры. Вот как раз между 50 и 500 и вставляем нашу сотню:) Или приведу пример из всех книжек — игра в карточного «Дурака». Когда мы тянем карту из колоды, смотрим на наши разложенные по возрастанию карты и в зависимости от достоинства вытянутой карты помещаем карту в соответствующее место. Для большей наглядности приведу анимацию из википедии.
———————
Картинка с анимацией из вики, у кости было видео кажется на эту тему интересное
——————
Давайте попробуем написать алгоритм этой сортировки
—————
#include <stdio.h>
#define SIZE 10

void printArr(int arr[SIZE]) {
	int i;
	for (i = 0; i < SIZE; i++) {
		printf("%3d ", arr[i]);
	}
	printf("\n");
}

void sortInserts (int arr[SIZE]) {
	int newElement, location;

	    for (int i = 1; i < SIZE; i++)
	    {
	        newElement = arr[i];
	        location = i - 1;
	        while(location >= 0 && arr[location] > newElement)
	        {
	            arr[location+1] = arr[location];
	            location = location - 1;
	        }
	        arr[location+1] = newElement;
	    }
}

int main () {
	int array[SIZE] = {4, 1, -7, 3, 6, 9, 2, 4, -3, 0};
	printArr(array);
	sortInserts(array);
	printArr(array);

	return 0;
}

/////////////6.2.4. Сортировка методом выбора
Осуществляется следующим образом: Мы ищем минимальный (или максимальный) элемент массива, в зависимости от того, как именно надо ранжировать массив, и ставим его в нулевой индекс. потом идём от первого в поиске следующего минимального и ставим его на первое место и так далее пока не дойдём до конца массива. Этот метод быстрее хотя бы просто потому что мы из каждого прохода цикла выбрасываем кучу операций присваивания. 
    int i, j;
    int jmin;
    for(i = 0; i < MaxN; i++)
    {
        jmin = i;
        for(j = i + 1; j < MaxN; j++)
            if (arr[j] < arr[jmin])
                jmin = j;
        five_swap(&arr[i], &arr[jmin]);

/////////////// 6.3. Алгоритмы поиска
Одним из важнейших действий со структурированной информацией является поиск. Поиск – процесс нахождения конкретной информации в ранее созданном множестве данных. Обычно данные представляют собой записи, каждая из которых имеет хотя бы один ключ. Ключ поиска – это поле записи, по значению которого происходит поиск. Ключи используются для отличия одних записей от других. Целью поиска является нахождение всех записей (если они есть) с данным значением ключа.

Структуру данных, в которой проводится поиск, можно рассматривать как таблицу символов (таблицу имен или таблицу идентификаторов) – структуру, содержащую ключи и данные, и допускающую две операции – вставку нового элемента и возврат элемента с заданным ключом. Иногда таблицы символов называют словарями по аналогии с хорошо известной системой упорядочивания слов в алфавитном порядке: слово – ключ, его толкование – данные.

Поиск является одним из наиболее часто встречаемых действий в программировании. Существует множество различных алгоритмов поиска, которые принципиально зависят от способа организации данных. У каждого алгоритма поиска есть свои преимущества и недостатки. Поэтому важно выбрать тот алгоритм, который лучше всего подходит для решения конкретной задачи.

Поставим задачу поиска в линейных структурах. Пусть задано множество данных, которое описывается как массив, состоящий из некоторого количества элементов. Проверим, входит ли заданный ключ в данный массив. Если входит, то найдем номер этого элемента массива, то есть, определим первое вхождение заданного ключа (элемента) в исходном массиве.

/////////////////6.3.1. Линейный поиск
Самый простой в реализации, но, естественно, не самый эффективный алгоритм поиска - это линейный алгоритм. Всем хорошо знакомый, где мы перебираем подряд все элементы массива и таким образом находим либо искомое значение, либо конец массива. 
  int value = 10;
  int a[N];
  int i;
  for (i = 0; i < N; i++){ a[i] = rand() % 100; }
  i=0;
  while(i < N && a[i] != value) i++; //Алгоритм поиска
  if (i != N)
  	printf("Index: %d Value: %d", i, a[i]);
  else
  	printf("Value not found");

	Сложность алгоритма линейная, производительность тоже линейная.

///////////////6.3.2. Поиск методом половинного деления
При использовании алгоритма поиска половинным делением мы делим массив, какой-бы он ни был длины пополам, и сравниваем серединное значение с искомым. Если искомое равно - прекрасно, если больше, то идём вправо, если меньше влево. таким образом время поиска весьма сокращается, поскольку нет смысла искать по всему массиву, зная, что он отсортирован по возрастанию.
   int value = 4;
   int L = 0,R = N - 1;
   int m = L + (R - L) / 2;
   while(L <= R && a[m] != value) {
   	if (a[m] < value)
           L = m + 1; 
       else 
           R = m - 1;
   	m = L + (R - L) / 2;
   }
   if (a[m] == value)
   	printf("Index: %d, Value: %d", m, a[m]);
   else
   	printf("Value not found");

///////////////6.3.3. Интерполяционный поиск
В основе поиска лежит не половинное деление, а примерный подсчёт, в какой области может лежать искомое значение. Например, если у нас есть массив из 200 элементов, и диапазон значений 0-99 то весьма велика вероятность того, что цифра 13 окажется где то в районе 15-30 места. Таким образом, на практике интерполяционный поиск часто быстрее бинарного.
	int mid;
	int low = 0;
	int high = len - 1;
	while(arr[low] < value && arr[high] > value)
	{
		mid = low + ((value - arr[low]) * (high - low)) / (arr[high] - arr[low]);
		if (arr[mid] < value)
			low = mid + 1;
		else if(arr[mid] > value)
			high = mid - 1;
		else
			return mid;
	}

	if (arr[low] == value)
		return low;
	else if (arr[high] == value)
		return high;
	else
		return -1;

////////////////6.4. Сложные сортировки
Переходим к сложным сортировкам.

////////////////6.4.1. Быстрая сортировка/Сортировка Хоара(Quick sort)
Это существенно улучшенный вариант пузырьковой и шейкерной сортировки. Принципиальное отличие состоит в том, что в первую очередь производятся перестановки на наибольшем возможном расстоянии и после каждого прохода элементы делятся на две независимые группы. Общая идея в следующем - выбираем элемент, называем его опорным, сравниваем остальные с опорным и переставляем их так, чтобы разбить на две группы: меньше опорного, равные или больше опорного. Для меньших и бОльших отрезков выполняем рекурсивно ту-же последовательность операций. Есть несколько вариантов быстрой сортировки и отличаются они выбором опорного элемента. Давайте рассмотрим реализацию выбора опорного элемента по алгоритму Хоара, поскольку она в среднем в три раза быстрее алгоритма ЛомутО. Сначала мы как-то выискиваем опорный элемент,
void qSort(int* arr, int min, int max) {
  if (min < max) {
	  int base = partition(arr, len, min, max);
		qSort(arr, min, base);
		qSort(arr, base + 1, max);
	}
}
А потом применяем тот же алгоритм к левой и правой части. А теперь собственно то, что придумал Чарльз Хоар
int partition(int* arr, len, min, max) {
  int b = arr[min];
	int i = (min > 0) ? min - 1 : 0;
	int j = (max < len - 1) ? max + 1 : len - 1;
	while (true) {
  	do {
  	  i++;
  	} while (arr[i] < b);
		do {
	    j--;
  	} while (arr[j] > b);
  	if (i >= j)
  	  return j;
  	swap(arr[i], arr[j]);
	}
}

Или можно написать сразу хорошую объединённую функцию
int n, a[n]; //n - количество элементов
void qs(int* s_arr, int first, int last)
{
    int i = first, j = last, x = s_arr[(first + last) / 2];
 
    do {
        while (s_arr[i] < x) i++;
        while (s_arr[j] > x) j--;
 
        if(i <= j) {
            if (s_arr[i] > s_arr[j]) swap(&s_arr[i], &s_arr[j]);
            i++;
            j--;
        }
    } while (i <= j);
 
    if (i < last)
        qs(s_arr, i, last);
    if (first < j)
        qs(s_arr, first, j);
}

////////////////6.4.2. Сортировка слиянием(Merge sort)
Сортировка слиянием — алгоритм сортировки, который упорядочивает списки (или другие структуры данных, доступ к элементам которых можно получать только последовательно, например — потоки) в определённом порядке.

Слияние означает объединение двух (или более) последовательностей в одну упорядоченную последовательность при помощи циклического выбора элементов, доступных в данный момент.

Сначала задача разбивается на несколько подзадач меньшего размера. Затем эти задачи решаются с помощью рекурсивного вызова или непосредственно, если их размер достаточно мал. Затем их решения комбинируются, и получается решение исходной задачи.
Процедура слияния предполагает объединение двух предварительно упорядоченных подпоследовательностей размерности n/2 в единую последовательность размерности n. Начальные элементы предварительно упорядоченных последовательностей сравниваются между собой, и из них выбирается наименьший. Соответствующий указатель перемещается на следующий элемент. Процедура повторяется до тех пор, пока не достигнут конец одной из подпоследовательностей. Оставшиеся элементы другой подпоследовательности при этом передаются в результирующую последовательность в неизменном виде.
Сортировка слиянием во многом похожа на метод быстрой сортировки.  Производительность сортировки слиянием лежит между производительностью пирамидальной и быстрой сортировки. Но в отличие от пирамидальной и быстрой сортировок, метод сортировки слиянием ведет себя стабильно, поскольку он не зависит от перестановок элементов в массиве.

Еще одним достоинством сортировки слиянием является то, что он удобен для структур с последовательным доступом к элементам, таким как файлы на внешнем устройстве или связные списки. Этот метод, прежде всего, используется для внешней сортировки.

Недостатки метода заключаются в том, что он требует дополнительной памяти по объему равной объему сортируемого файла. Поэтому для больших файлов проблематично организовать сортировку слиянием в оперативной памяти.

В случаях, когда гарантированное время сортировки важно и размещение в оперативной памяти, возможно, следует предпочесть метод сортировки слиянием.
Существует три алгоритма для речения такой сортировки - алгоритм двухпудового слияния, алгоритм нисходящего слияния и алгоритм восходящего слияния. 

Алгоритм двухпутевого слияния:
Заданная последовательность разбивается на две подпоследовательности, которые далее разбиваются на еще меньшие последовательности, пока не остается по 2 элемента, которые сравниваются между собой, далее все отсортированные двойки сливаются в одну последовательность. Далее последовательность снова разбивается, образуются отсортированные четверки, которые сливаются в одну последовательность. Данная операция повторяется до тех пор, пока полученная упорядоченная последовательность не будет иметь такой же размер, как у сортируемой.
Основной операцией является слияние. При слиянии требуется дополнительная память для размещения файла, образующегося при слиянии. Операция линейно зависит от количества элементов в объединяемых массивах.

Метод нисходящего слияния
Исходная последовательность рекурсивно разбивается на половины, пока не получим подпоследовательности по 1 элементу. Из полученных подпоследовательностей формируем упорядоченные пары методом слияния, затем - упорядоченные четверки и т.д.
______________
Картинка
________________

Метод восходящего слияния 
В методе восходящего слияния отсутствует процедура рекурсивного разделения последовательности пополам. Исходная последовательность представляется как последовательный набор отдельных элементов. Рассмотрим этот алгоритм более подробно.
—————————
Код с сайта (рабочий)
—————————

#include <stdio.h>
#include <stdlib.h>
#define SIZE 15
// Метод восходящего слияния
void mergeSort(int *a, int n)
{
  int step = 1;  // шаг разбиения последовательности
  int *temp = (int*)malloc(n * sizeof(temp)); // дополнительный массив
  while (step < n)  // пока шаг меньше длины массива
  {
    int index = 0;    // индекс результирующего массива
    int l = 0;      // левая граница участка
    int m = l + step;  // середина участка
    int r = l + step * 2;  // правая граница участка
    do
    {
      m = m < n ? m : n;  // сортируемый участок не выходит за границы последовательности
      r = r < n ? r : n;
      int i1 = l, i2 = m; // индексы сравниваемых элементов
      for (; i1 < m && i2 < r; ) // пока i1 не дошёл до середины и i2 не дошёл до конца
      {
        if (a[i1] < a[i2]) { temp[index++] = a[i1++]; } // заполняем участок результирующей последовательности
        else { temp[index++] = a[i2++]; }
      }
      // Или i1 < m или i2 < r - только один из операторов while может выполниться
      while (i1 < m) temp[index++] = a[i1++]; // заносим оставшиеся элементы сортируемых участков
      while (i2 < r) temp[index++] = a[i2++]; // в результирующий массив
      l += step * 2; // перемещаемся на следующий сортируемый участок
      m += step * 2;
      r += step * 2;
    } while (l < n); // пока левая граница сортируемого участка - в пределах последоватльности
    for (int i = 0; i < n; i++) // переносим сформированный массив обратно в a
      a[i] = temp[i];
    step *= 2; // увеличиваем в 2 раза шаг разбиения
  }
}
int main()
{
  int a[SIZE];
  // Заполняем элементы массива
  for (int i = 0; i<SIZE; i++)
  {
    a[i] = (rand() % 100);
    printf(" %d ", a[i]);
  }
  mergeSort(a, SIZE); // вызываем функцию сортировки
  printf("\n");
  // Выводим отсортированный массив
  for (int i = 0; i<SIZE; i++)
    printf(" %d ", a[i]);
  getchar();
  return 0;
}

////////////////6.4.3. Сортировка подсчётом(Counting sort)
Это, пожалуй, простейший алгоритм с линейной сложностью. Для его реализации берётся вспомогательный частотный массив и затем этот массив считывается, формируя упорядоченную последовательность. Используется как для простых так и для сложных объектов, главное определить параметры сортировки. То есть нам же надо понимать как сортировать, например, коробки, по длине, ширине или вовсе по объёму. Мы не будем останавливаться на этой сортировке, так как она не универсальная, а перейдем сразу к улучшенной ее версии.

////////////////6.4.4. Алгоритм со списком(pigeonhole sorting)
Это вариант сортировки подсчётом, просто частотный вспомогательный массив создаётся с минимумом и максимумом из всех возможных вариантов. Часто применяется для сортировки библиотечных данных key-value по числовому ключу.
Реализацию такого метода показывает следующий код:

#include <stdio.h>
#define SIZE 13

int findMin (int* arr) {
   int min = arr[0];
   for (int i = 0; i < SIZE; i++) {
       if (min >= arr[i]) min = arr[i];
   }
   return min;
}

int findMax (int* arr) {
        int max = arr[0];
        for (int i = 0; i < SIZE; i++) {
            if (max <= arr[i]) max = arr[i];
        }
        return max;
    }

void printArr(int* arr) {
	int i;
	for(i = 0; i < SIZE; i++) {
		printf("%d ", arr[i]);
	}
	printf("\n");
}

void sortCount(int* arr) {
    int min = findMin(arr);
    int max =  findMax(arr);
    int spread = abs(min) + abs(max);
    const int LEN = spread + 1;
    int supportArr[LEN];
    int i;
    for (i = 0; i < LEN; i++) {
        supportArr[i] = 0;
    }

    for (i = 0; i < SIZE; i++) {
        supportArr[arr[i] - min]++;
    }

    int count = 0;
    for (int i = 0; i < LEN; i++) {
        while (supportArr[i] > 0) {
        	arr[count] = i + min;
        	count++;
        	supportArr[i]--;
        }
    }
}


int main () {
	int arr[SIZE] = {2, 6, -9, 12, 56, 6, 34, 90, 5, 2, -6, 8, -23};
	printArr(arr);
	sortCount(arr);
	printArr(arr);

	return 0;
}

////////////////6.4.5. Блочная сортировка
Сортировка в которой некий числовой ряд распределяется между конечным числом отдельных блоков, таким образом, чтобы каждый элемент в каждом следующем блоке был больше (или меньше) чем в предыдущем. и затем сортируется каждый блок по отдельности

void bucket(int* array, int size) {
  const int max = size;
	const int buckets = 10; // for ex values 0-99, 10 buckets 
	int i, j;
	int bucket[buckets][max + 1]; // last index for counters
	for (i = 0; i < buckets; i++)
	  bucket[i][max] = 0;

	int digit;
	for (digit = 1; digit <= size; digit *= 10)
    for (i = 0; i < max; i++) {
		  int num = (array[i] / digit) % (size / buckets);
			bucket[num][bucket[num][max]++] = array[i];
		}
		
		int idx = 0;
		for (i = 0; i < buckets; i++) {
		  for (j = 0; j < bucket[i][max]; y++) {
			  array[idx++] = bucket[x][y];
			}
		  bucket[i][max] = 0;
		}
	}
}

////////////////6.4.6. Улучшенная сортировка вставками (Сортировка Шелла)
Идея метода заключается в сравнение разделенных на группы элементов последовательности, находящихся друг от друга на некотором расстоянии. Изначально это расстояние равно d или N/2, где N — общее число элементов. На первом шаге каждая группа включает в себя два элемента расположенных друг от друга на расстоянии N/2; они сравниваются между собой, и, в случае необходимости, меняются местами. На последующих шагах также происходят проверка и обмен, но расстояние d сокращается на d/2, и количество групп, соответственно, уменьшается. Постепенно расстояние между элементами уменьшается, и на d=1 проход по массиву происходит в последний раз.
#include <stdio.h>

void printArr(int arr[], int N) {
	int i;
	for (i = 0; i < N; i++) {
		printf("%3d ", arr[i]);
	}
	printf("\n");
}

void sortShells(int arr[], int N) {
	int i,j,k;
	int t;
	for(k = N / 2; k > 0; k /= 2) {
        for(i = k; i < N; i++) {
            t = arr[i];
            for(j = i; j >= k; j -= k) {
                if(t < arr[j - k]) {
                    arr[j] = arr[j - k];
                } else
                    break;
            }
            arr[j] = t;
        }
	}
}

int main () {
	int size = 10;
	int array[] = {4, 1, -7, 3, 6, 9, 2, 4, -3, 0};
	printArr(array, size);
	sortShells(array, size);
	printArr(array, size);

	return 0;
}
